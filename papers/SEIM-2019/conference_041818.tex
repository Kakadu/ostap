\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}

\lstdefinelanguage{ocaml}{
keywords={ostap, let, begin, end, in, match, type, and, fun, 
function, try, with, class, object, method, of, rec, repeat, until,
while, not, do, done, as, val, inherit, module, sig, @type, struct, 
if, then, else, open, virtual, new, fresh},
sensitive=true,
basicstyle=\normalsize\ttfamily,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\underline,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to$}}3
         {===}{{$\equiv$}}1
}

\lstset{
extendedchars=\true,
basicstyle=\normalsize,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
escapechar=!,
language=ocaml,
mathescape=true
}

\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}


\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\pagestyle{plain}

\begin{document}

\title{Левая рекурсия в монадических парсер-комбинаторах}

\author{\IEEEauthorblockN{Данила Боровков}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
Санкт-Петербург, Россия \\
danila.borovkov1996@gmail.com}
}

\maketitle

\begin{abstract}



\end{abstract}

\begin{IEEEkeywords}



\end{IEEEkeywords}

\section{Введение}

Синтаксический анализ заключается в проверке соответствия анализируемого текста некоторой грамматике и получении некоторой информации, зачастую представленную в виде дерева синтаксического анализа. Синтаксический анализ является важной областью программирования, которой посвящено множество работ. Программное обеспечение, выполняющее синтаксический анализ, называется синтаксическим анализатором или парсером. Однако в большинстве случаев пользователю нужно не само дерево анализа, а некоторый результат или конструкция, задаваемая пользователем. Поэтому действительно представляют интерес парсеры, предоставляющие возможность задавать пользовательскую семантику синтаксического разбора, а не просто строящие дерево разбора.

Одним из самых простых и удобных подходов к построению синтаксических анализаторов по входной грамматике являются парсер-комбинаторы~\cite{meijer}. Парсер-комбинатор~--- это функция высшего порядка, принимающая парсеры в качестве аргументов, конcтруирующая из них другой парсер и возвращающая его в качестве результата. Во многом этот подход похож на расширенную форму Бэкуса-Наура: парсер-комбинаторы соответствуют примитивам, а элементарные парсеры -- терминалам. Помимо удобства и простоты преимуществом парсер-комбинаторов является возможность использования для описания анализаторов конструкций языка, на котором ведется разработка, что позволяет, например, создавать анализаторы высшего порядка.

Исследована связь парсер-комбинаторов с таким математическим объектом, как монада~\cite{meijer,wadler}, позволяющим формально представить вычислительный процесс и его побочные эффекты. Было показано, что анализаторы могут быть реализованы в виде монад, что предоставляет возможность построить математическую модель процесса синтаксического анализа. Помимо этого, сами монадические парсер-комбинаторы удобны для использования: например, они позволяют описывать синтаксический анализ некоторых контекстно-зависимых языков.

Однако у применения классических парсер-комбинаторов имеются существенные трудности, а именно: правило longest match first и левая рекурсия. Правило longest match first заключается в том, что при использовании альтернативы анализатор с более длинным результатом должен быть рассмотрен в первую очередь. Если не следовать этой стратегии и составлять альтернативы иным способом, то это приведет к трудно отслеживаемым ошибкам в работе описываемого анализатора. Второй трудностью является левая рекурсия в грамматике анализируемого языка, которая приводит к зацикливанию синтаксических анализаторов. Поэтому эти алгоритмы предполагают, что грамматика описываемого анализатора будет без леворекурсивных правил. В примитивных случаях это можно обеспечить с помощью алгоритмов по переводу грамматики в форму без леворекурсивных правил, однако в случае описания анализаторов высшего порядка распознавание левой рекурсии является неразрешимой задачей.

Чувствительность к левой рекурсии и принципу ''longest match first''~--- две основные проблемы парсер-комбинаторов, решению которых посвящено множество работ~\cite{frost,tratt,warth}, однако до сих пор никто не справлялся с этими трудностями так успешно как авторы работы~\cite{meerkat}. Существенным минусом данной реализации является построение сжатого леса разбора (SPPF) вместо работы с пользовательской семантики. Поэтому было решено адаптировать подход из этой работы для монадических парсер-комбинаторов c пользовательской семантикой, взяв в качестве основы существующую библиотеку парсер-комбинаторов Ostap~\cite{ostap} по причине того, что она использует классические монадические парсер комбинаторы, а значит имеет все описанные выше недостатки. 

\section{Связанные работы}

\subsection{Левая рекурсия}

Левая рекурсия является классической проблемой, когда речь идет о синтаксическом анализе, однако в случае парсер-комбинаторов эта проблема доставляет гораздо больше проблем. Для реализации эффективных и переиспользуемых библиотек необходимо использовать парсеры высших порядков, однако в таком случае невозможно определить наличие левой рекурсии, а значит невозможно статически от нее избавиться с помощью классических методов.

\begin{center}
    \texttt{A[B] : B ...}~--- леворекурсивен, если $\mathtt{A[B]} \equiv B$
  \end{center}
  
В этом примере показан парсер высшего порядка А, параметризованный парсером B. Парсер А работает таким образом, что в первую очередь будет выполнен разбор с помощью парсера-параметра, а затем уже остальные действия, скрытые под ''...''. Такой парсер сам по себе нелеворекурссивен, однако парсер А может быть использован таким образом, что левая рекурсия появится.

\subsection{Принцип ''longest match first''}

Принцип ''longest match'' заключается в том, что в классических парсер-комбинаторах альтернатива работает согласно ожиданиям только если первый парсер не разбирает префикс никакого слова, разбираемого вторым парсером. Например в выражении 

  \begin{center}
    \verb/opnd (">=" | ">") opnd/
  \end{center}
  
нельзя поменять местами \verb/">="/ и \verb/">"/. Помимо очевидных проблем и ошибок связанных с неправильным порядком парсеров, при использовании парсеров высших порядков может оказаться так, что невозможно заранее определить правильный порядок в альтернативе
.
\subsection{Подходы к мемоизации}
Мемоизация некоторой функции заключается в том, что результаты выполнения функции сохраняются для того, чтобы исключить повторные запуски. Именно мемоизация является основным иструментов для борьбы с левой рекурсией. Существует большое количество применений мемоизации к синтаксическому анализу~\cite{frost,tratt,warth}, однако у большниства имеются существенные недостатки, такие как недостаточная производительность или проблемы с выразительностью. Авторами библиотеки Meerkat~\cite{meerkat} была предложена мемоизация совершенно нечувствительная к левой рекурсии и правилу ''longest match first''. Их парсеры производят построение SPPF, однако нам более предпочтительно использование пользовательской семантики. Это и тот факт, что реализованные в библиотеке Meerkat парсер-комбинаторы не являются монадическими, являются причинами доработки этого алгоритма в рамках библиотеки Ostap.

\subsection{Ostap}

Библиотека Ostap написанная Д. Ю. Булычевым представляет из себя библиотеку классических монадических парсер-комюинаторов написанных в direct style. Для избежания сложностей связанных с использованием парсер-комбинаторов было реализовано синтаксическое расширение языка OCaml, предоставляющее DSL для описания парсеров. Этот язык очень схож с формой Бэкуса-Наура для описания грамматик, то есть он интуитивен и очень прост в использовании. Далее представлен пример парсера, написанный с помощью DSL библиотеки Ostap.

\begin{lstlisting}
   ostap (
     primary: c:IDENT {`N c} ;

     exp[primary]:
        e:exp[primary] -"+" p:primary {`E2 (e, p)}
      | p:primary {`E1 p} ;

     main: exp[primary] -EOF
   )
  \end{lstlisting}

В библиотеке Ostap используется объектно-ориентированное представление входного потока и для описания разбора лексем IDENT из строки 2 и EOF из строки 8 у объекта входного потока, переданного этому парсеру, должны быть реализованы методы getIDENT и getEOF, в которых описывает лексический анализ для лексем IDENT и EOF.

При описании парсеров пользователь может задать свою семантику разбора в фигурных скобках. При этом имеется возможность использовать результаты разбора с каждого шага с помощью переменных.

\section{Парсер-комбинаторы}
В данном разделе речь пойдет о том как были реализованы парсер-комбинаторы. Сначала будут описаны типы новых парсер-комбинаторов, потом будет показана реализация простейших парсеров, затем будут представлены сами парсер-комбинаторы, и, наконец, будет описана и обоснована их связь с монадами.

\subsection{Типы}
В первую очередь разберемся с типами наших парсеров.

\begin{lstlisting}
    type ($\alpha$, $\beta$) tag =
      Parsed of $\alpha$ * $\beta$ option
    | Failed of $\beta$ option
    | Empty
    type ($\sigma$, $\alpha$, $\beta$) result = ($\alpha$ * $\sigma$, $\beta$) tag
    type ($\alpha$, $\sigma$, $\beta$, $\gamma$) k = $\alpha$ -> $\sigma$ -> ($\sigma$, $\beta$, $\gamma$) result
    type ($\alpha$, $\sigma$, $\beta$, $\gamma$) parser = $\sigma$ -> ($\alpha$, $\sigma$, $\beta$, $\gamma$) k -> ($\sigma$, $\beta$, $\gamma$) result
  \end{lstlisting}
  
В строке 1 представлен тип tag, который имеет три возможных результата. Parsed означает успешный результат анализа и ему передается пара из некоторой информация полученной в процессе анализа, семантика и возможной информации об ошибке. Failed означает неудачу и содержит возможную информацию об ошибке. Empty означает, что ничего не произошло, парсер не был запущен. 

В строке 5 описан типа результат парсера -- это tag, которому в первом аргументе передается пара из значения, полученного в процессе анализа с помощью пользовательской семантики, и остатка входной строки, а во втором передается тип возможной ошибки.

В строке 6 показан тип продолжения, которое принимает два аргумента и возвращает результат. Первый из этих аргументов -- это тип монадического значения, которое передается от текущего парсера следующему. Второй аргумент -- это остаток входной строки, который остался после запуска предыдущего парсера и на котором должен быть запущен следующий парсер.

В строке 7, наконец, можно увидеть тип парсера. У парсера 2 аргумента -- входная строка, на которой парсер должен быть запущен, и продолжение, которое представляет из себя весь остальной анализ и должно быть запущено по окончании разбора.

\subsection{Простейшие парсеры}
Расмотрим для лучшего понимания как выглядят простейшие парсеры.

\begin{lstlisting}
   let empty =
     fun s k -> return () s k
\end{lstlisting}

Выше представлен парсер empty, который представляет из себя пустую последовательность символов. Он принимает на вход входной поток и продолжение, как с вссе парсеры, но ничего не делает с ними и просто вызывает продолжение, передав ему пустое монадическое значение и неизменный входной поток.

\begin{lstlisting}
   let fail =
     fun r s k -> Failed r
\end{lstlisting}

В строке 1 описан парсер fail, который завершает анализ ошибкой. Для этого достаточно просто вернуть результат Failed и так как продолжение не было вызвано анализ прекратится.

\subsection{Парсер-комбинаторы}
Основными парсер-комбинаторами данной реализации являются seq и alt, которые описаны дальше.

\begin{lstlisting}
   let seq =
     fun x y s k -> x s (kmemo (fun a s' -> y a s' k))
\end{lstlisting}

Парсер-комбинатор seq принимает на вход два аргумента: парсер и нечто, принимающее на вход какое-то значение возвращающее парсер, и возвращает парсер, который представляет из себя последовательный анализ двумя парсерами. В этой реализацции напрямую используются продолжения: в строке 2 происходит вызов первого парсер-аргумента и при этом ему передается входной поток, на котором происходит вызов seq, и продолжение, в котором происходит вызов второго аргумента на остатке строки и продолжении для парсера-результата seq. Функция kmemo обеспечивает единственный вызов продолжений на одних и тех же аргументах. Она не является необходимой частью алгоритма, однако она существенно улучшает скорость работы построенных парсеров.

Тепер рассмотрим парсер-комбинатор alt.

\begin{lstlisting}
   let alt =
     fun x y -> memo (fun s k -> (x s k) <@> (y s k))
\end{lstlisting}

У парсер-комбинатора alt оба аргумента -- парсеры, причем с одинаковыми типами. В строке 2 происходит вызов обоих парсеров и выбор одного из результатов, реализованный с помощью оператора <@>. Именно в этом комбинаторе скрывается алгоритм мемоизации, предложенный авторами библиотеки Meerkat, и выражена она в функции memo в строке 2. Эта функция принимает на вход парсер и возвращает парсер, разбирающий тот же язык. Разница заключается в том, что при вызове парсера-результат происходит заполнение таблиц мемоизации. Про повторном вызове этого парсера в продолжении произойдет обращение к этим таблицам во избежание зацикливания при левой рекурсии.

\subsection{Монадические парсер-комбинаторы}
Теперь, когда были описаны парсер-комбинаторы и простейшие парсеры можно провести параллель с монадами.

В работе~\cite{wadler} было показано, что если взять seq в качестве bind, а empty в качестве return, то парсер будет удовлетворять условиям монады. Помимо этого, если alt взять как plus, а fail None как zero, то парсер будет монадой плюс. 

Такой монадический seq оказывается очень удобным для использования в парсер-комбинаторах с пользовательской семантикой. Рассмотрим как должен выглядеть комбинатор seq: должны быть произведены два последовательных запуска парсеров-аргументов и эти два результата должны быть склеены каким-то образом. В случае парсеров с построением дерева разбора их можно просто скеить в узел дерева, но если необходимо строить пользовательскую семантику, то это функция слеивания двух семантик должна быть передана этому seq, потому что она задается пользователем и никак не может быть жестко прописана в парсер-комбинаторе. И монадческий seq делает простую вещь: он объединяет функцию склеивания со вторым парсером и получается второй аргумент из листинга seq. Такое решение оказывается не только удобным, но и довольно выразительным: с помощью такого seq можно реализовать не только контекстно-свободные конструкции, но и некоторые контекстно-зависимые конструкции.

\section{Реализация новых комбинаторов}

При реализации новых монадических парсер-комбинаторов в первую очередь были выбраны типы для продолжений и парсеров, которые сочетаются с парсер-комбинаторами из библиотеки Meerkat. затем были внесены необходмые изменения в алгоритм мемоизации для работы с монадическими парсер-комбинаторами и реализованы все парсеры, необходимые для библиотеки Ostap. Для правильной типизации входного потока, представленного объектом, были использованы явно-полиморфные типы и генерируемые ограничения типов. Для правильной работы мемоизации для парсеров выссшего порядка был использован генерируемый комбинатор неподвижной точки.

\subsection{Типы}

При выборе типов мы отталкивались от реализации парсер-комбинатора seq, потому что именно в нем выражается монадичность парсеров и наиболее явно используются продолжения.

\begin{lstlisting}
   let Meerkat_seq =
     fun x y s k -> x s (kmemo (fun s' -> y s' k))
     
   let monadic_seq =
     fun x y s k -> x s (kmemo (fun a s' -> y a s' k))
\end{lstlisting}

С одной стороны реализация seq авторов библиотеки Meerkat предполагает передачу второго парсера в качества аргумента первому. С другой стороны, первый парсер должен передавать второму свой результат с помощью монадического значения. Так как первый парсер передает управление второму с помощью вызова продолжения, то при этом вызове необходимо передавать и монадческое значение. Поэтому в продолжения был добавлен еще один аргумент -- монадическое значение и в реализации монадического seq передавать это значение второму аргументу seq.

Теперь перейдем к описанию типов.

\begin{lstlisting}
    type ($\alpha$, $\beta$) tag =
      Parsed of $\alpha$ * $\beta$ option
    | Failed of $\beta$ option
    | Empty
  \end{lstlisting}
  
Здесь представлен тип tag, который имеет три возможных результата. Parsed означает успешный результат анализа и содержит некоторую информацию, полученную в процессе анализа, и возможную информацию об ошибке. Failed означает неудачу и содержит возможную информацию об ошибке. Empty означает, что ничего не произошло, парсер не был запущен. 

\begin{lstlisting}
   type ($\sigma$, $\alpha$, $\beta$) result = ($\alpha$ * $\sigma$, $\beta$) tag
  \end{lstlisting}
  
В этой строке описан типа результат парсера -- это tag, параметрами которого являются следующие типы:  пара $\alpha$ * $\sigma$, где $\alpha$ -- это тип значения, полученного в процессе анализа с помощью пользовательской семантики, а $\sigma$ -- тип входной строки, и $\beta$ -- тип возможной ошибки.

\begin{lstlisting}
   type ($\alpha$, $\sigma$, $\beta$, $\gamma$) k = $\alpha$ -> $\sigma$ -> ($\sigma$, $\beta$, $\gamma$) result
  \end{lstlisting}
  
Продолжение принимает два аргумента и возвращает результат, тип которого был описан ранее. Первый из этих аргументов, $\alpha$ -- это тип монадического значения, которое передается от текущего парсера следующему. Второй аргумент, $\sigma$ -- это остаток входной строки, который остался после запуска предыдущего парсера и на котором должен быть запущен следующий парсер.

\begin{lstlisting}
   type ($\alpha$, $\sigma$, $\beta$, $\gamma$) parser = $\sigma$ -> ($\alpha$, $\sigma$, $\beta$, $\gamma$) k -> ($\sigma$, $\beta$, $\gamma$) result
  \end{lstlisting}

Здесь, наконец, можно увидеть тип парсера. У парсера 2 аргумента -- $\sigma$ : входная строка, на которой парсер должен быть запущен, и продолжение, которое представляет из себя весь остальной анализ и должно быть запущено по окончании разбора.

\subsection{Алгоритм мемоизации для монадических парсер-комбинаторов}

Реализация комбинатора alt интереса не представляет, потому что она не была изменена при адаптации алгоритма. Мемоизация же, выраженная в функции memo, претерпела некоторые изменения. Помимо добавления дополнительного аргумента в описание продолжений, необходимо было учитывать его при заполнении таблиц мемоизации. 

\begin{lstlisting}

let memoresult =
  fun p ->
    let ss : ('stream * 'a) list ref = ref      [] in
    let ks :                K.ks ref = ref K.empty in
    fun k ->
      if $\mbox{(* это первый запуск p *) }$
      then (
        ks := K.singleton k;
        p (fun a s -> 
            $\mbox{(* если (s, a) не было в ss}$
                  $\mbox{записываем ее в ss и}$
                  $\mbox{все продолжения из ks запускаем на ней}$
              $\mbox{иначе возвращаем Empty *)}$
          )
          )
      else $\mbox{(* это повторный запуск p *) }$
        (ks := K.add k !ks;
        
        $\mbox{
         (* запуск k на всех сохраненных в ss парах *) }$
        )
   
  \end{lstlisting}

Алгоритм мемоизации в целом изменен не был -- также используются две таблицы: с продолжениями и с параметрами продолжений. При появлении нового продолжения происходит сохранение его в соответствующую таблицу и вызов его на всех сохраненных параметрах. При вызове какого-либо продолжения парсера p на новых параметрах происходит сохранение этих параметров и вызов вссех сохраненных продолжений на них.

Некоторые изменения, однако, были неизбежны. В качестве переменной ss вместо списка входных строк, на которых вызывались продолжения мемоизироваемого парсера, был использован список пар из входной строки и монадического значения, потому что теперь продолжения вызываются на двух аргументах. Для получения структур, которые можно модифицировать в продолжениях были ипользованы ссылки, как при описании таблицы ss, так и ks.

В 13 строке был использован новый вид результата -- Empty. В данном случае некорректно возвращать Failure, потому что никакой ошибки не произошло, ведь просто нет необходимости вызывать продолжение еще раз, поэтому вызова не происсходит. Именно об этом и говорит результат Empty -- о том, что никаких продолжений вызвано не было, но это не связано с ошибкой, это связано с работой алгоритма.

Для хранения продолжений был разработан модуль K, который помимо самого хранилища продолжений K.ks предоставляет несколько полезных функций, например функции K.singleton и K.add, которые позволяют создавать новое хранилище с одним продолжением и добавлять продолжение в уже существующее хранилище соответственно. Для правильного сравнения продолжений между собой необходимо использовать системный модуль Obj и функцию Obj.magic. Поэтому, чтобы не осложнять этими деталями алгоритм мемоизации, было решено выделить эту часть реализаии в отдельный модуль.

\subsection{Манипуляции с продолжениями в реализаии комбинатора opt}

Помимо стандартных парсер-комбинаторов alt и seq в библиотеке Ostap используется еще несколько удобных комбинаторов. Одним из таких является комбинатор opt, который имеет один аргумент -- парсер. На выходе opt выдает парсер, который либо не делает ничего, либо совершает разбор с помощью парсера-аргумента, и возвращает результат типа option = Some a | None. Ниже представлена реализация этого комбинатора в стиле передачи продолжений.

\begin{lstlisting}
let wrong_opt p = alt p empty

let opt =
  fun p ->
    memo (fun s k -> let s' = Oo.copy s in
                     let k' = memo_k (fun a s -> k (Some a) s) in
                     (p s k') <@> (k None s'))
\end{lstlisting}

В первую очередь хотелось бы обратить внимание на то, что этот комбинатор не реализовать с помощью alt так просто, как показано в строке 1. Связано это с тем, что использование комбинатора alt подразумевает, что типы обоих парсеров-аргументов и результирующего парсера должны совпадать, но в случае opt это не так. С другой стороны, если забыть о типах, то, по сути, реализация в строке 1 верная. Для правильной работы были внесены исправления в реализацию комбинатора alt как показано в строке 5. При этом создается новое продолжение k', которое уже можно использовать в парсере-аргументе в отличие от k, работа которого полностью дублирует работу k в случае, если opt выполняет разбор с помощью парсера-аргумента. Именно оно затем и передается парсеру-аргументу в строке 8. Вариант пустого разбора для opt реализуется с помощью вызова продолжения k на значении None.

\subsection{Явно-полиморфные типы}

Как уже было сказано в обзоре, входной поток представляется с помощью объекта, и методы этого объекта вида getLEXEM описывают лексический анализ соответствующих лексем. Из-за того, что в методах объекта не может быть свободных переменных были использованы полиморфные типы у методов входного потока как показано ниже. 

\begin{lstlisting}
  < 
    getCONST : $\beta$ . ($\alpha$ -> 'self -> ('self, $\beta$, $\gamma$) result) ->
                         ('self, $\beta$, $\gamma$) result;
    ..
  >
\end{lstlisting}

В этом примере можно увидеть, что тип метода getCONST полиморфен по переменной $\beta$ -- типу пользовательской семантики. В отличии от переменной $\alpha$, значение переменной $\beta$ невозможно установить лишь по этому методу, потому что ее значение будет известно только из продолжения, но его тип не установить заранее, потому что пользовательская семантика не может ограничиваться принадлежностью к какому-либо типу. При реализации парсер-комбинаторов такой проблемы не возникало, потому что тип пользовательской семантики просто был свободной переменной, однако в данном случае так сделать нельзя.

Помимо того, что необходимо явно прописывать типы у методов в описании входного потока, их также необходимо прописывать при вызове этих самых методов.

\subsection{Генерируемая неподвижная точка}

Для того, чтобы таблицы мемоизации не создавались повторно в случае рекурсивных вызовов, было необходимо использовать комбинатор неподвижной точки при описании парсеров. Из-за того, что парсеры могут использовать друг друга в процессе разбора был использован генерируемый комбинатор неподвижной точки для нескольких функций.

\begin{lstlisting}
    ostap (x : "a"; y[z] : y[z] "+" x | x)

                $\Downarrow$
         
    let (x, y) = 
      let generated_fixpoint = ... in
      let x'   = fun x y -> ostap ("a")
      and y' z = fun x y -> ostap (y[z] "+" x | x)
    in generated_fixpoint x' y' 
\end{lstlisting}

В данном примере описывается 2 парсера: x и y, и поэтому генерируется двуместный комбинатор неподвижной точки. Помимо этого для работы комбинатора неподвижной точки необходима генерация парсеров освобожденных от рекурсивных высовов x' и y'. Как можно увидеть в строке 7 функция x' имеет два дополнительных аргумента по сравнению с x, которые для простоты называются х и у. При этом тела функций х и x' никак не отличаются. Таким образов все рекурсивные вызовы парсеров x и y в описании этих самых парсером заменены на вызовы аргументов x'. Именно в таком виде комбинатор неподвижной точки принимает на вход обрабатываемые функции.

С помощью генерируемого комбинатора неподвижной точки получилось избавиться и от еще одной проблемы: в случае использования параметризованных парсеров и при повторном вызове на одном и том же параметре таблицы мемоизации создавались повторно. Для решения этой проблемы внутри комбинатора неподвижной точки генерируется код для мемоизации парсера по всем его параметрам. Этот код проверяет вызывался ли парсер высшего порядка на текущем параметре и берет уже полученное и сохраненное значение в случае повторного вызова. Таким образом комбинатор неподвижной точки генерировался не только в зависимости от количества описываемых парсеров, но и в зависимости от количества параметров у каждого из них.

\section{Тестирование и апробация}

Описанная в предыдущих разделах модификация монадических парсер-комбинаторов обладает следующими преимуществами по сравнению с исходной реализацией:

\begin{itemize}
  \item поддержкой произвольного порядка альтернатив без использования правила ``longest match first'';
  \item поддержкой левой рекурсии;
  \item более высокой производительностью за счет мемоизации.
\end{itemize}

Все эти свойства были подтверждены экспериментально.

В первую очередь было проведено регрессионное тестирование на стандартном наборе тестов, входящих в состав оригинальной библиотеки Ostap. Это тестирование показало,
что новая реализация парсер-комбинаторов полностью покрывает функциональность исходной библиотеки. При этом тесты, написанные с применением синтаксического расширения (то есть
используя более высокоуровневый интерфейс, чем примитивные комбинаторы) вообще не подвергались никакой модификации. Тесты же на индивидуальные комбинаторы были модифицированы
незначительно~--- к вызовам парсеров на самом верхнем уровне были добавлены тривиальные продолжения.

Помимо регрессионных тестов для проверки функциональности был использован синтаксический анализатор учебного языка, используемого в курсе
компиляторов\footnote{https://compscicenter.ru/courses/compilers/2018-spring}. Эталонный компилятор, собранный с помощью новой реализации библиотеки, прошел все
регрессионные тесты без модификации. Таким образом было подтверждено отсутствие регресса по сравнению с исходной библиотекой.

\subsection{Нечувствительность с правилу ''longest match first''}

В эталонном компиляторе, упомянутом выше, есть фрагмент, где нарушение правила ``longest match first'' приводит к возникновению труднообнаружимых отложенных ошибок.
Этот фрагмент локализован в реализации парсера выражений:

\begin{lstlisting}
  Ostap.Util.expr
  [|                
    `Lefta, [$\verb/"!!"/$];
    `Lefta, [$\verb/"&&"/$];
    `Nona , [$\verb/"=="/$; $\verb/"!="/$; $\verb/"<="/$; $\verb/"<"/$; $\verb/">="/$; $\verb/">"/$];
    `Lefta, [$\verb/"++"/$; $\verb/"+"/$; $\verb/"-"/$];
    `Lefta, [$\verb/"*"/$; $\verb/"//"$; $\verb/"%"/$];
  |] 
\end{lstlisting}

В данном фрагменте используется утилита \lstinline|Util.expr|. Она позволяет описывать выражения
с бинарными и унарными операциями разного старшинства и ассоциативности с помощью простых конструкций. Строка, начинающаяся с \lstinline|`Nona|, описывает неассоциативные
операции в выражениях. В реализации утилиты \lstinline|Util.expr| она будет преобразована в несколько последовательных альтернатив из парсеров соответствующих
строк-элементов массива. Поэтому в данном случае раньше необходимо было следовать правилу ''longest match first'', хотя использование альтернативы и скрыто от пользователя
с помощью утилиты \lstinline|Util.expr|. На практике это означало, что порядок знаков операций имел значение: например, нельзя было указать знак операции ``<'' \emph{раньше}
знака операции ``<='', поскольку строка ``<'' является подстрокой ``<=''. То же самое было верно и для знаков ``++'' и ``+'' ниже по тексту фрагмента.

Для проверки того, что от правила ``longest match first'' можно отказаться при использовании реализации парсеров в новой версии библиотеки, знаки ``>'' и ``>='' были
переставлены местами. Оказалось, что, действительно, такие парсеры работают, причем работают с одинаковой скоростью для любого порядка знаков.

\subsection{Использование леворекурсивных описаний}

Еще одним интересным местом в реализации парсера эталонного компилятора является описание оператора ``;'':

\begin{lstlisting}
  parse:
        s:stmt ";" ss:parse {Seq (s, ss)}
      | stmt;
\end{lstlisting}

В этом листинге представлена реализациия парсера \lstinline|parse|, который анализирует последовательности вида ``\lstinline|stmt; stmt; ...; stmt|''. При использовании старой
версии Ostap необходимо было использовать именно эту нелеворекурсивную реализацию~--- самым левым нетерминалом должен был быть \lstinline|stmt|, а не \lstinline|parse|. Реализация,
представленная ниже, раньше не работала именно по этой причине:

\begin{lstlisting}
  parse:
        ss:parse ";" s:stmt {Seq (ss, s)}
      | stmt;
\end{lstlisting}

Здесь парсер \lstinline|parse| описан леворекурсивно~--- самым левым нетерминалом является \lstinline|parse|~--- поэтому происходило зацикливание алгоритма разбора. 

Для проверки новой версии библиотеки была использована вторая реализация, при этом парсер остался работоспособным и время его работы не изменилось.

\subsection{Повышение производительности}

Для сравнения производительности старой и новой версии библиотеки была использована та же реализация эталонного компилятора, что и в предыдущих разделах. В качестве тестового
набора использовались сгенерированные программы вида ``\lstinline|x1 := {expr}|'' для разной длины выражения.  Были проведены также замеры и для строк с несколькими
выражениями, то есть вида ``\lstinline|x1 := {expr}; ... xn := {expr}|'', однако оказалось, что время работы на таких входах пропорционально времени работы для одного присваивания,
поэтому для оценки производительности такие тесты далее не использовались. Тем не менее тестирование на нескольких присваиваниях выявило интересное свойство новой реализации:
увеличение числа присваиваний пропорционально увеличивает глубину рекурсивных вызовов для новой версии (при использовании старой версии такого не наблюдается). Это связано с тем,
что новая версия использует гораздо более глубокие рекурсивные вызовы, так как парсер-комбинатор \lstinline|seq| реализован таким образом, что второй парсер запускается в продолжении,
а значит требует дополнительное место на стеке. Поэтому при использовании новой версии необходимо правильно конфигурировать среду времени исполнения для выделения достаточного
количества памяти под стек.

Результаты апробации показаны в таблице~\ref{tab1}. Видно, что парсеры, написанные с помощью новой версии библиотеки, работают в несколько раз быстрее по сравнению со старой версией.
В первом столбце показан размер выражения (число знаков бинарных операций), а в двух других представлено время работы в секундах парсера эталонного компилятора, собранного с помощью старой версии библиотеки, и того же парсера, собранного с помощью новой версии.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Размер} & \multicolumn{2}{|c|}{\textbf{Время разбора, cек.}} \\
\cline{2-3} 
\textbf{примера} & \textbf{Старая версия} & \textbf{Новая версия} \\
\hline
25& 0,25& 0,13 \\
\hline
50& 0,52& 0,24 \\
\hline
100& 2,13& 0,56 \\
\hline
200& 9,19& 1,97 \\
\hline
300& 21,93& 4,61 \\
\hline
400& 42,65& 9,50 \\
\hline
\end{tabular}
\vskip3mm
\caption{Результаты сравнения производительности старой и новой реализаций библиотеки}
\label{tab1}
\end{center}
\end{table}


\section{Заключение}

В рамках данной работы была выполнена реализация монадических парсер-комбинаторов использующих пользовательскую семантику. На основе алгоритма авторов библиотеки Meerkat был
разработан адаптированный алгоритм, который далее был интегрирован в библиотеку Ostap. 

\begin{thebibliography}{00}
\bibitem{meerkat} A. Izmaylova, A. Afroozeh, and T. van der Storm T. Practical, General Parser Combinators // PEPM '16 Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation, pp. 1--12, 2016.
\bibitem{ostap} D. Boulytchev. Ostap: Parser Combinator Library and Syntax Extension for Objective Caml, 2009.
\bibitem{boulytchev2015combinators} D. Boulytchev. Combinators and type-driven transformers in objective caml // Science of Computer Programming, Vol. 114, Elsevier, pp. 57--73, 2015.
\bibitem{meijer} G. Hutton and E. Meijer. Monadic Parser Combinators // Technical Report NOTTCS-TR-96-4, Department of Computer Science, University of Nottingham, 1996.
\bibitem{wadler} Ph. Wadler. Monads for functional programming // Proc. Marktoberdorf Summer school on program design calculi, 1992.
\bibitem{tratt} L. Tratt. Direct Left-Recursive Parsing Expression Grammars // Technical Report EIS-10-01, Middlesex University, 2010.
\bibitem{frost} R. A. Frost, R. Hafiz, and P. Callaghan. Parser Combinators for Ambiguous Left-Recursive Grammars // Practical Aspects of Declarative Languages, PADL’08, 2008.
\bibitem{warth} A. Warth, J. R. Douglass, and T. Millstein. Packrat Parsers Can Support Left Recursion // Partial Evaluation and Semantics-based Program Manipulation, PEPM ’08, pp. 103--110, 2016.
\bibitem{ford2002packrat} B. Ford. Packrat parsing:: simple, powerful, lazy, linear time, functional pearl // ACM SIGPLAN Notices, Vol. 37, No. 9, ACM, 2002.
\bibitem{ford2004parsing} B. Ford. Parsing expression grammars: a recognition-based syntactic foundation // ACM SIGPLAN Notices, Vol. 39, No. 1, ACM, 2004.
\bibitem{swierstra2001combinator} S. D. Swierstra. Combinator parsers: From toys to tools // Electronic Notes in Theoretical Computer Science, Vol. 41, No. 1, Elsevier, pp. 38--59, 2001.
\bibitem{knuth1968semantics} D. E. Knuth. Semantics of context-free languages // Mathematical systems theory, Vol. 2, No. 2, Springer, pp. 127--145, 1968.

\end{thebibliography}

\end{document}
