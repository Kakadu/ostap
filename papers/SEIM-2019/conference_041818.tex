\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}

\lstdefinelanguage{ocaml}{
keywords={ostap, let, begin, end, in, match, type, and, fun,
function, try, with, class, object, method, of, rec, repeat, until,
while, not, do, done, as, val, inherit, module, sig, @type, struct,
if, then, else, open, virtual, new, fresh},
sensitive=true,
basicstyle=\normalsize\ttfamily,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\underline,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to$}}3
         {===}{{$\equiv$}}1
}

\lstset{
extendedchars=\true,
basicstyle=\normalsize,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
%escapechar=!,
language=ocaml,
mathescape=true
}

\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}


\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\pagestyle{plain}

\begin{document}

\title{Левая рекурсия в монадических парсер-комбинаторах}

\author{\IEEEauthorblockN{Данила Боровков}
\IEEEauthorblockA{\textit{JetBrains Research} \\
\textit{JetBrains}\\
Санкт-Петербург, Россия \\
danila.borovkov1996@gmail.com}
}

\maketitle

\begin{abstract}



\end{abstract}

\begin{IEEEkeywords}
\end{IEEEkeywords}

\section{Введение}

Синтаксический анализ заключается в проверке соответствия анализируемого текста некоторой грамматике и получении некоторой информации, зачастую представленную в виде дерева синтаксического анализа. Синтаксический анализ является важной областью программирования, которой посвящено множество работ. Программное обеспечение, выполняющее синтаксический анализ, называется синтаксическим анализатором или парсером. Однако в большинстве случаев пользователю нужно не само дерево анализа, а некоторый результат или конструкция, задаваемая пользователем. Поэтому действительно представляют интерес парсеры, предоставляющие возможность задавать пользовательскую семантику синтаксического разбора, а не просто строящие дерево разбора.

Одним из самых простых и удобных подходов к построению синтаксических анализаторов по входной грамматике являются парсер-комбинаторы~\cite{meijer}. Парсер-комбинатор~--- это функция высшего порядка, принимающая парсеры в качестве аргументов, конcтруирующая из них другой парсер и возвращающая его в качестве результата. Во многом этот подход похож на расширенную форму Бэкуса-Наура: парсер-комбинаторы соответствуют примитивам, а элементарные парсеры~--- терминалам. Помимо удобства и простоты преимуществом парсер-комбинаторов является возможность использования для описания анализаторов конструкций языка, на котором ведется разработка, что позволяет, например, создавать анализаторы высшего порядка.

Исследована связь парсер-комбинаторов с таким математическим объектом, как монада~\cite{meijer,wadler}, позволяющим формально представить вычислительный процесс и его побочные эффекты. Было показано, что анализаторы могут быть реализованы в виде монад, что предоставляет возможность построить математическую модель процесса синтаксического анализа. Помимо этого, сами монадические парсер-комбинаторы удобны для использования: например, они позволяют описывать синтаксический анализ некоторых контекстно-зависимых языков.

Однако у применения классических парсер-комбинаторов имеются существенные трудности, а именно: правило longest match first и левая рекурсия. Правило longest match first заключается в том, что при использовании альтернативы анализатор с более длинным результатом должен быть рассмотрен в первую очередь. Если не следовать этой стратегии и составлять альтернативы иным способом, то это приведет к трудно отслеживаемым ошибкам в работе описываемого анализатора. Второй трудностью является левая рекурсия в грамматике анализируемого языка, которая приводит к зацикливанию синтаксических анализаторов. Поэтому эти алгоритмы предполагают, что грамматика описываемого анализатора будет без леворекурсивных правил. В примитивных случаях это можно обеспечить с помощью алгоритмов по переводу грамматики в форму без леворекурсивных правил, однако в случае описания анализаторов высшего порядка распознавание левой рекурсии является неразрешимой задачей.

Чувствительность к левой рекурсии и принципу ``longest match first''~--- две основные проблемы парсер-комбинаторов, решению которых посвящено множество работ~\cite{frost,tratt,warth}, однако до сих пор никто не справлялся с этими трудностями так успешно как авторы работы~\cite{meerkat}. Существенным минусом данной реализации является построение сжатого леса разбора (SPPF) вместо работы с пользовательской семантики. Поэтому было решено адаптировать подход из этой работы для монадических парсер-комбинаторов c пользовательской семантикой, взяв в качестве основы существующую библиотеку парсер-комбинаторов Ostap~\cite{ostap} по причине того, что она использует классические монадические парсер комбинаторы, а значит имеет все описанные выше недостатки.

\section{Связанные работы}

\subsection{Левая рекурсия}

Левая рекурсия является классической проблемой, когда речь идет о синтаксическом анализе, однако в случае парсер-комбинаторов эта проблема доставляет гораздо больше проблем.
Для реализации эффективных и переиспользуемых библиотек необходимо использовать парсеры высших порядков, однако в таком случае невозможно определить наличие левой рекурсии,
а значит невозможно статически от нее избавиться с помощью классических методов.

\begin{center}
    \texttt{A[B] : B ...}~--- леворекурсивен, если $\mathtt{A[B]} \equiv B$
  \end{center}

В этом примере показан парсер высшего порядка \lstinline|А|, параметризованный парсером \lstinline|B|. Парсер \lstinline|А| работает таким образом, что в первую очередь будет
выполнен разбор с помощью парсера-параметра, а затем уже остальные действия, скрытые под ``...''. Такой парсер сам по себе нелеворекурссивен, однако парсер \lstinline|А| может
быть использован таким образом, что левая рекурсия появится.

\subsection{Принцип ``longest match first''}

Принцип ``longest match'' заключается в том, что в классических парсер-комбинаторах альтернатива работает согласно ожиданиям только если первый парсер не разбирает префикс
никакого слова, разбираемого вторым парсером. Например в выражении

  \begin{center}
    \verb/opnd (">=" | ">") opnd/
  \end{center}

нельзя поменять местами ``>='' и ``>''. Помимо очевидных проблем и ошибок связанных с неправильным порядком парсеров, при использовании парсеров высших порядков может оказаться так,
что невозможно заранее определить правильный порядок в альтернативе
.
\subsection{Подходы к мемоизации}
Мемоизация некоторой функции заключается в том, что результаты выполнения функции сохраняются для того, чтобы исключить повторные запуски. Именно мемоизация является основным инструментом
для борьбы с левой рекурсией. Существует большое количество применений мемоизации к синтаксическому анализу~\cite{frost,tratt,warth}, однако у большинства имеются существенные недостатки,
 такие как недостаточная производительность или проблемы с выразительностью. Авторами библиотеки Meerkat~\cite{meerkat} была предложена мемоизация совершенно нечувствительная к левой
 рекурсии и правилу ``longest match first''. Их парсеры производят построение SPPF, однако нам более предпочтительно использование пользовательской семантики. Это и тот факт, что реализованные
 в библиотеке Meerkat парсер-комбинаторы не являются монадическими, являются причинами доработки этого алгоритма в рамках библиотеки Ostap.

\subsection{Ostap}

Библиотека Ostap~\cite{ostap} представляет из себя библиотеку классических монадических парсер-комбинаторов, написанных в direct style. Для избежания сложностей, связанных с
использованием парсер-комбинаторов, было реализовано синтаксическое расширение языка OCaml, предоставляющее DSL для описания парсеров. Этот язык очень схож с формой Бэкуса-Наура
для описания грамматик, то есть он интуитивен и очень прост в использовании. Далее представлен пример парсера, написанный с помощью DSL библиотеки Ostap.

\begin{lstlisting}
   ostap (
     primary: c:IDENT {`N c} ;

     exp[primary]:
        e:exp[primary] -"+" p:primary {`E2 (e, p)}
      | p:primary {`E1 p} ;

     main: exp[primary] -EOF
   )
  \end{lstlisting}

В библиотеке Ostap используется объектно-ориентированное представление входного потока, и для описания разбора токенов \lstinline|IDENT| из строки 2 и \lstinline|EOF| из строки 8 у
объекта входного потока, переданного этому парсеру, должны быть реализованы методы \lstinline|getIDENT| и \lstinline|getEOF|, в которых описывает лексический анализ для соответствующих лексем.

При описании парсеров пользователь может задать свою семантику разбора в фигурных скобках. При этом имеется возможность использовать результаты разбора с каждого шага с помощью переменных.

\section{Парсер-комбинаторы}

В данном разделе речь пойдет о том как были реализованы парсер-комбинаторы. Сначала будут описаны типы новых парсер-комбинаторов, потом будет показана реализация простейших парсеров,
затем будут представлены сами парсер-комбинаторы, и, наконец, будет описана и обоснована их связь с монадами.

\subsection{Типы}
В первую очередь разберемся с типами наших парсеров.

\begin{lstlisting}
    type ($\alpha$, $\beta$) tag =
      Parsed of $\alpha$ * $\beta$ option
    | Failed of $\beta$ option
    | Empty
    type ($\sigma$, $\alpha$, $\beta$) result = ($\alpha$ * $\sigma$, $\beta$) tag
    type ($\alpha$, $\sigma$, $\beta$, $\gamma$) k = $\alpha$ -> $\sigma$ -> ($\sigma$, $\beta$, $\gamma$) result
    type ($\alpha$, $\sigma$, $\beta$, $\gamma$) parser = $\sigma$ -> ($\alpha$, $\sigma$, $\beta$, $\gamma$) k -> ($\sigma$, $\beta$, $\gamma$) result
  \end{lstlisting}

В строке 1 представлен тип tag, который имеет три возможных результата. Parsed означает успешный результат анализа и ему передается пара из некоторой информация полученной в процессе анализа, семантика и возможной информации об ошибке. Failed означает неудачу и содержит возможную информацию об ошибке. Empty означает, что ничего не произошло, парсер не был запущен.

В строке 5 описан типа результат парсера~--- это tag, которому в первом аргументе передается пара из значения, полученного в процессе анализа с помощью пользовательской семантики, и остатка входной строки, а во втором передается тип возможной ошибки.

В строке 6 показан тип продолжения, которое принимает два аргумента и возвращает результат. Первый из этих аргументов~--- это тип монадического значения, которое передается от текущего парсера следующему. Второй аргумент~--- это остаток входной строки, который остался после запуска предыдущего парсера и на котором должен быть запущен следующий парсер.

В строке 7, наконец, можно увидеть тип парсера. У парсера 2 аргумента~--- входная строка, на которой парсер должен быть запущен, и продолжение, которое представляет из себя весь остальной анализ и должно быть запущено по окончании разбора.

\subsection{Простейшие парсеры}
Расмотрим для лучшего понимания как выглядят простейшие парсеры.

\begin{lstlisting}
   let empty =
     fun s k -> return () s k
\end{lstlisting}

Выше представлен парсер empty, который представляет из себя пустую последовательность символов. Он принимает на вход входной поток и продолжение, как с вссе парсеры, но ничего не делает с ними и просто вызывает продолжение, передав ему пустое монадическое значение и неизменный входной поток.

\begin{lstlisting}
   let fail =
     fun r s k -> Failed r
\end{lstlisting}

В строке 1 описан парсер fail, который завершает анализ ошибкой. Для этого достаточно просто вернуть результат Failed и так как продолжение не было вызвано анализ прекратится.

\subsection{Парсер-комбинаторы}
Основными парсер-комбинаторами данной реализации являются seq и alt, которые описаны дальше.

\begin{lstlisting}
   let seq =
     fun x y s k -> x s (kmemo (fun a s' -> y a s' k))
\end{lstlisting}

Парсер-комбинатор seq принимает на вход два аргумента: парсер и нечто, принимающее на вход какое-то значение возвращающее парсер, и возвращает парсер, который представляет из себя последовательный анализ двумя парсерами. В этой реализацции напрямую используются продолжения: в строке 2 происходит вызов первого парсер-аргумента и при этом ему передается входной поток, на котором происходит вызов seq, и продолжение, в котором происходит вызов второго аргумента на остатке строки и продолжении для парсера-результата seq. Функция kmemo обеспечивает единственный вызов продолжений на одних и тех же аргументах. Она не является необходимой частью алгоритма, однако она существенно улучшает скорость работы построенных парсеров.

Тепер рассмотрим парсер-комбинатор alt.

\begin{lstlisting}
   let alt =
     fun x y -> memo (fun s k -> (x s k) <@> (y s k))
\end{lstlisting}

У парсер-комбинатора alt оба аргумента~--- парсеры, причем с одинаковыми типами. В строке 2 происходит вызов обоих парсеров и выбор одного из результатов, реализованный с помощью оператора <@>. Именно в этом комбинаторе скрывается алгоритм мемоизации, предложенный авторами библиотеки Meerkat, и выражена она в функции memo в строке 2. Эта функция принимает на вход парсер и возвращает парсер, разбирающий тот же язык. Разница заключается в том, что при вызове парсера-результат происходит заполнение таблиц мемоизации. Про повторном вызове этого парсера в продолжении произойдет обращение к этим таблицам во избежание зацикливания при левой рекурсии.

\subsection{Монадические парсер-комбинаторы}
Теперь, когда были описаны парсер-комбинаторы и простейшие парсеры можно провести параллель с монадами.

В работе~\cite{wadler} было показано, что если взять seq в качестве bind, а empty в качестве return, то парсер будет удовлетворять условиям монады. Помимо этого, если alt взять как plus, а fail None как zero, то парсер будет монадой плюс.

Такой монадический seq оказывается очень удобным для использования в парсер-комбинаторах с пользовательской семантикой. Рассмотрим как должен выглядеть комбинатор seq: должны быть произведены два последовательных запуска парсеров-аргументов и эти два результата должны быть склеены каким-то образом. В случае парсеров с построением дерева разбора их можно просто скеить в узел дерева, но если необходимо строить пользовательскую семантику, то это функция слеивания двух семантик должна быть передана этому seq, потому что она задается пользователем и никак не может быть жестко прописана в парсер-комбинаторе. И монадческий seq делает простую вещь: он объединяет функцию склеивания со вторым парсером и получается второй аргумент из листинга seq. Такое решение оказывается не только удобным, но и довольно выразительным: с помощью такого seq можно реализовать не только контекстно-свободные конструкции, но и некоторые контекстно-зависимые конструкции.

\section{Реализация новых комбинаторов}

Новые парсер-комбинаторы совмещают в себе, с одной стороны, использование продолжений и мемоизацию со стороны Meerkat, и, с другой~--- монадичность и пользовательскую семантику со стороны Ostap.
Это привело к тому, что новые комбинаторы обладают рядом отличительных черт по сравнению с обеими исходными библиотеками:

\begin{itemize}
\item по сравнению с Meerkat:

\begin{itemize}
\item изменился тип продолжений из-за необходимости обеспечения передачи монадических значений;
\item мемоизация учитывает монадические значения и параметры парсеров высшего порядка.
\end{itemize}

\item по сравнению с Ostap:

\begin{itemize}
\item все базовые комбинаторы переписаны в форму передачи продолжений;
\item введены явно-полиморфные типы методов для объектов, представляющих входной поток;
\item использована генерируемая неподвижная точка для группы взаимно-рекурсивных определений парсеров.
\end{itemize}
\end{itemize}

Далее мы более подробно опишем реализацию существенных составных частей новых комбинаторов.

\subsection{Типы}

При определении типов мы отталкивались от реализации парсер-комбинатора \lstinline|seq|, потому что именно в нем выражается монадичность парсеров и наиболее явно используются продолжения
(реализация комбинатора \lstinline|alt| интереса не представляет, потому что она не была изменена при адаптации алгоритма). Реализация \lstinline|seq| в библиотеке Meerkat
предполагает передачу второго парсера в качества аргумента первому:

\begin{lstlisting}[basicstyle=\small]
   fun x y s k -> x s (kmemo (fun s' -> y s' k))
\end{lstlisting}

Здесь \lstinline|x| и \lstinline|y|~--- парсеры, выступающие в качестве аргументов \lstinline|seq|, \lstinline|s|~--- входной поток, \lstinline|k|~--- продолжение,
\lstinline|kmemo|~--- примитив мемоизации.

В монадическом случае первый парсер должен передавать второму свой результат с помощью монадического значения. Так как первый парсер передает управление второму с
помощью вызова продолжения, то при этом вызове необходимо передавать и монадическое значение. Поэтому для продолжений был добавлен еще один аргумент~--- монадическое
значение \lstinline|a|, и комбинатор \lstinline|seq| приобрел следующий вид:

\begin{lstlisting}[basicstyle=\small]
   fun x y s k -> x s (kmemo (fun a s' -> y a s' k))
\end{lstlisting}

Теперь перейдем к описанию типов. Прежде всего, введем следующий тип:

\begin{lstlisting}
   type ($\alpha$, $\beta$) tag =
     Parsed of $\alpha$ * $\beta$ option
   | Failed of $\beta$ option
   | Empty
\end{lstlisting}

Этот тип описывает три возможных результата применения парсера к входному потоку. \lstinline|Parsed| означает успешный результат анализа и содержит некоторую информацию, полученную в процессе
анализа, и возможную информацию об ошибке. \lstinline|Failed| означает неудачу и содержит возможную информацию об ошибке. \lstinline|Empty| означает, что ничего не произошло, парсер не был запущен.
Далее этот тип будет использоваться специальным образом, для чего введем следующий синоним:

\begin{lstlisting}
   type ($\sigma$, $\alpha$, $\beta$) result = ($\alpha$ * $\sigma$, $\beta$) tag
\end{lstlisting}

Здесь $\alpha$~--- это тип значения, полученного в процессе анализа с помощью пользовательской семантики, $\sigma$~--- тип входного потока, $\beta$~--- тип возможной ошибки.

Тип продолжения \lstinline|k| вводится следующим образом:

\begin{lstlisting}
   type ($\alpha$, $\sigma$, $\beta$, $\gamma$) k =
      $\alpha$ -> $\sigma$ -> ($\sigma$, $\beta$, $\gamma$) result
\end{lstlisting}

Продолжение~--- это функция, которая принимает два аргумента и возвращает результат, тип которого был описан ранее. Первый из этих аргументов, $\alpha$~--- это тип монадического значения,
которое передается от текущего парсера следующему. Второй аргумент, $\sigma$~--- это остаток входного потока, который остался после запуска предыдущего парсера и на котором должен быть
запущен следующий парсер.

Наконец, тип парсера определяется так:

\begin{lstlisting}
   type ($\alpha$, $\sigma$, $\beta$, $\gamma$) parser =
      $\sigma$ -> ($\alpha$, $\sigma$, $\beta$, $\gamma$) k -> ($\sigma$, $\beta$, $\gamma$) result
\end{lstlisting}

Парсер~--- это функция от двух аргументов: входного потока и продолжения. Здесь $\sigma$~--- тип входного потока, $\alpha$~--- тип монадического значения, $\beta$~--- тип результата, $\gamma$~---
тип ошибки.

\subsection{Мемоизация монадических парсер-комбинаторов}

Мемоизация в библиотеке Meerkat использует три функции: \lstinline|kmemo|, \lstinline|memo| и \lstinline|memoresult|.

Функция \lstinline|kmemo| имеет один аргумент~--- продолжение~--- и обеспечивает, что это продолжение будет вызвано на одном и том же наборе аргументов только один раз. Для этого используется
таблица для хранения результатов предыдущих запусков продолжения.

Функция \lstinline|memo| имеет один аргумент~--- парсер \lstinline|p|~--- и выполняет его мемоизацию. Ключевая часть мемоизации заключается в вызове функции \lstinline|memoresult| на
частично-примененном к входному потоку \lstinline|p|, об этой функции будет рассказано ниже. Для того, чтобы вызов \lstinline|memoresult| происходил только один раз в
реализации \lstinline|memo|, используется таблица для хранения результатов запусков. Реализация функций \lstinline|kmemo| и \lstinline|memo| не была изменена по сравнению с
библиотекой Meerkat, поэтому обратимся к функции \lstinline|memoresult|, которая претерпела некоторые изменения.

Алгоритм мемоизации в целом изменен не был~--- так же используются две таблицы: с продолжениями и с параметрами продолжений. При появлении нового продолжения происходит сохранение
его в соответствующую таблицу и вызов его на всех сохраненных параметрах. При вызове какого-либо продолжения частично-примененного парсера \lstinline|p| на новых параметрах происходит сохранение этих
параметров и вызов всех сохраненных продолжений на них:

\begin{lstlisting}[basicstyle=\small]
  let memoresult = fun p ->
    let ss : ('stream * 'a) list ref = ref      [] in
    let ks :                K.ks ref = ref K.empty in
    fun k ->
      if $\mbox{это первый запуск p}$
      then (
        ks := K.singleton k;
        p (fun a s ->
            $\mbox{если (s, a) не было в ss}$
            $\mbox{записываем ее в ss и}$
            $\mbox{запускаем на ней все продолжения из ks}$
            $\mbox{иначе возвращаем Empty}$
          )
      )
      else (
        ks := K.add k !ks;
        $\mbox{запустить k на всех сохраненных в ss парах}$
      )
\end{lstlisting}

Некоторые изменения, однако, были неизбежны. В качестве переменной  \lstinline|ss| вместо списка входных строк, на которых вызывались продолжения мемоизироваемого парсера, был использован список
пар из входной строки и монадического значения, потому что теперь продолжения вызываются на двух аргументах. Для получения структур, которые можно модифицировать в продолжениях были
использованы ссылки, как при описании таблицы \lstinline|ss|, так и \lstinline|ks|.

В реализации мемоизации был использован новый вид результата~--- \lstinline|Empty|. В данном случае некорректно возвращать \lstinline|Failure|, потому что никакой ошибки не произошло,
ведь просто нет необходимости вызывать продолжение еще раз, поэтому вызова не происходит. Именно об этом и говорит результат \lstinline|Empty|~--- о том, что никаких продолжений
вызвано не было, но это не связано с ошибкой, это связано с работой алгоритма.

Для хранения продолжений был разработан модуль \lstinline|K|, который помимо самого хранилища продолжений \lstinline|K.ks| предоставляет несколько полезных функций, например
функции \lstinline|K.singleton| и  \lstinline|K.add|, которые позволяют создавать новое хранилище с одним продолжением и добавлять продолжение в уже существующее хранилище
соответственно. Для правильного сравнения продолжений между собой необходимо использовать внутренний модуль \lstinline|Obj| и функцию неконтролируемого преобразования типов
\lstinline|Obj.magic|. Введение дополнительного модуля позволило инкапсулировать использование небезопасных примитивов.

\subsection{Реализация комбинатора \lstinline|opt|}

Помимо стандартных парсер-комбинаторов \lstinline|alt| и \lstinline|seq| в библиотеке Ostap используется еще несколько удобных комбинаторов. Одним из таких является комбинатор
\lstinline|opt|, который имеет один аргумент~--- парсер. На выходе \lstinline|opt| выдает парсер, который либо не делает ничего, либо совершает разбор с помощью парсера-аргумента,
и возвращает результат типа \lstinline|$\alpha$ option|.

В первую очередь хотелось бы обратить внимание на то, что этот комбинатор нельзя реализовать с помощью комбинатора \lstinline|alt| как показано ниже:

\begin{lstlisting}[basicstyle=\small]
  let opt p = alt p empty
\end{lstlisting}

Это связано с тем, что использование комбинатора \lstinline|alt| подразумевает, что типы обоих парсеров-аргументов и результирующего парсера должны совпадать,
но в случае \lstinline|opt| это не так. Правильная реализация такова:

\begin{lstlisting}[basicstyle=\small]
  let opt = fun p -> memo (fun s k ->
    let s' = Oo.copy s in
    let k' = kmemo (fun a s -> k (Some a) s) in
    (p s k') <@> (k None s'))
\end{lstlisting}

По существу здесь использована специализированная версия реализации комбинатора \lstinline|alt|. Так как продолжение \lstinline|k| из-за неподходящего типа не может быть передано парсеру
\lstinline|p|, для его запуска используется новое продолжение \lstinline|k'|. В его реализации происходит необходимое изменение типа монадического значения
с некоторого $\alpha$ на \lstinline| $\alpha$  option| и мемоизация нового продолжения с помощью функции \lstinline|kmemo|. Затем это продолжение используется для
запуска парсера \lstinline|p|. Вариант пустого разбора комбинатора \lstinline|opt| реализуется с помощью вызова продолжения \lstinline|k| с монадическим значением \lstinline|None|,
которое показывает, что \lstinline|opt| не разобрал ничего.

\subsection{Явно-полиморфные типы}

Как уже было сказано в обзоре, входной поток в Ostap представляется с помощью объекта, и методы этого объекта вида \lstinline|getTOKEN| описывают лексический анализ
соответствующих лексем. Из-за того, что в типах методов объекта не может быть свободных переменных, возникла необходимость использовать явно-полиморфные типы:

\begin{lstlisting}[basicstyle=\small]
  < getCONST :
     $\beta$ . ($\alpha$ -> 'self -> ('self, $\beta$, $\gamma$) result) ->
               ('self, $\beta$, $\gamma$) result;
    .. >
\end{lstlisting}

В этом примере можно увидеть, что тип метода \lstinline|getCONST| явно-полиморфен по переменной $\beta$~--- типу пользовательской семантики. В отличии от переменной $\alpha$,
значение переменной $\beta$ невозможно установить лишь по этому методу, потому что ее значение будет известно только из продолжения, но его тип не установить заранее,
потому что пользовательская семантика не может ограничиваться принадлежностью к какому-либо типу. При реализации парсер-комбинаторов такой проблемы не возникало,
потому что тип пользовательской семантики просто был свободной переменной, однако в данном случае так сделать нельзя.

Помимо того, что необходимо явно прописывать типы у методов в описании входного потока, их также необходимо специфицировать при вызове.

\subsection{Генерируемая неподвижная точка}

Для того, чтобы таблицы мемоизации не создавались повторно в случае рекурсивных вызовов, необходимо использовать комбинатор неподвижной точки при описании парсеров.
Из-за того, что парсеры могут использовать друг друга в процессе разбора был использован генерируемый комбинатор неподвижной точки для нескольких функций. Продемонстрируем
это на следующем примере:

\begin{lstlisting}[basicstyle=\small]
    ostap (x : "a"; y[z] : y[z] "+" x | x)

                $\Downarrow$

    let (x, y) =
      let generated_fixpoint = ... in
      let x'   = fun x y -> ostap ("a")
      and y' z = fun x y -> ostap (y[z] "+" x | x)
    in generated_fixpoint x' y'
\end{lstlisting}

Здесь описывается два парсера \lstinline|x| и \lstinline|y|, и поэтому генерируется двуместный комбинатор неподвижной точки. Помимо этого для работы комбинатора неподвижной
точки необходима генерация освобожденных от рекурсивных вызовов парсеров \lstinline|x'| и \lstinline|y'|. Как можно видеть, функция \lstinline|x'| имеет два дополнительных
аргумента по сравнению с \lstinline|x|, которые для простоты называются \lstinline|х| и \lstinline|у|. При этом тела функций \lstinline|х| и \lstinline|x'| никак не отличаются.
Таким образов все рекурсивные вызовы парсеров \lstinline|x| и \lstinline|y| в описании этих самых парсером заменены на вызовы аргументов \lstinline|x'| и  \lstinline|y'|.
Именно в таком виде комбинатор неподвижной точки принимает на вход обрабатываемые функции.

С помощью генерируемого комбинатора неподвижной точки получилось избавиться и от еще одной проблемы: в случае использования параметризованных парсеров и при повторном вызове на
одном и том же параметре таблицы мемоизации создавались повторно. Для решения этой проблемы внутри комбинатора неподвижной точки генерируется код для мемоизации парсера по всем
его параметрам. Этот код проверяет, вызывался ли парсер высшего порядка на текущем параметре, и берет уже полученное и сохраненное значение в случае повторного вызова.
Таким образом, комбинатор неподвижной точки генерируется не только в зависимости от количества описываемых парсеров, но и в зависимости от количества параметров у каждого из них.

\section{Тестирование и апробация}

Описанная в предыдущих разделах модификация монадических парсер-комбинаторов обладает следующими преимуществами по сравнению с исходной реализацией:

\begin{itemize}
  \item поддержкой произвольного порядка альтернатив без использования правила ``longest match first'';
  \item поддержкой левой рекурсии;
  \item более высокой производительностью за счет мемоизации.
\end{itemize}

Все эти свойства были подтверждены экспериментально.

В первую очередь было проведено регрессионное тестирование на стандартном наборе тестов, входящих в состав оригинальной библиотеки Ostap. Это тестирование показало,
что новая реализация парсер-комбинаторов полностью покрывает функциональность исходной библиотеки. При этом тесты, написанные с применением синтаксического расширения (то есть
используя более высокоуровневый интерфейс, чем примитивные комбинаторы) вообще не подвергались никакой модификации. Тесты же на индивидуальные комбинаторы были модифицированы
незначительно~--- к вызовам парсеров на самом верхнем уровне были добавлены тривиальные продолжения.

Помимо регрессионных тестов для проверки функциональности был использован синтаксический анализатор учебного языка, используемого в курсе
компиляторов\footnote{https://compscicenter.ru/courses/compilers/2018-spring}. Эталонный компилятор, собранный с помощью новой реализации библиотеки, прошел все
регрессионные тесты без модификации. Таким образом было подтверждено отсутствие регресса по сравнению с исходной библиотекой.

\subsection{Нечувствительность с правилу ``longest match first''}

В эталонном компиляторе, упомянутом выше, есть фрагмент, где нарушение правила ``longest match first'' приводит к возникновению труднообнаружимых отложенных ошибок.
Этот фрагмент локализован в реализации парсера выражений:

\begin{lstlisting}
  Ostap.Util.expr
  [|
    `Lefta, [$\verb/"!!"/$];
    `Lefta, [$\verb/"&&"/$];
    `Nona , [$\verb/"=="/$; $\verb/"!="/$; $\verb/"<="/$; $\verb/"<"/$; $\verb/">="/$; $\verb/">"/$];
    `Lefta, [$\verb/"++"/$; $\verb/"+"/$; $\verb/"-"/$];
    `Lefta, [$\verb/"*"/$; $\verb/"//"$; $\verb/"%"/$];
  |]
\end{lstlisting}

В данном фрагменте используется утилита \lstinline|Util.expr|. Она позволяет описывать выражения
с бинарными и унарными операциями разного старшинства и ассоциативности с помощью простых конструкций. Строка, начинающаяся с \lstinline|`Nona|, описывает неассоциативные
операции в выражениях. В реализации утилиты \lstinline|Util.expr| она будет преобразована в несколько последовательных альтернатив из парсеров соответствующих
строк-элементов массива. Поэтому в данном случае раньше необходимо было следовать правилу ``longest match first'', хотя использование альтернативы и скрыто от пользователя
с помощью утилиты \lstinline|Util.expr|. На практике это означало, что порядок знаков операций имел значение: например, нельзя было указать знак операции ``<'' \emph{раньше}
знака операции ``<='', поскольку строка ``<'' является подстрокой ``<=''. То же самое было верно и для знаков ``++'' и ``+'' ниже по тексту фрагмента.

Для проверки того, что от правила ``longest match first'' можно отказаться при использовании реализации парсеров в новой версии библиотеки, знаки ``>'' и ``>='' были
переставлены местами. Оказалось, что, действительно, такие парсеры работают, причем работают с одинаковой скоростью для любого порядка знаков.

\subsection{Использование леворекурсивных описаний}

Еще одним интересным местом в реализации парсера эталонного компилятора является описание оператора ``;'':

\begin{lstlisting}
  parse:
        s:stmt ";" ss:parse {Seq (s, ss)}
      | stmt;
\end{lstlisting}

В этом листинге представлена реализациия парсера \lstinline|parse|, который анализирует последовательности вида ``\lstinline|stmt; stmt; ...; stmt|''. При использовании старой
версии Ostap необходимо было использовать именно эту нелеворекурсивную реализацию~--- самым левым нетерминалом должен был быть \lstinline|stmt|, а не \lstinline|parse|. Реализация,
представленная ниже, раньше не работала именно по этой причине:

\begin{lstlisting}
  parse:
        ss:parse ";" s:stmt {Seq (ss, s)}
      | stmt;
\end{lstlisting}

Здесь парсер \lstinline|parse| описан леворекурсивно~--- самым левым нетерминалом является \lstinline|parse|~--- поэтому происходило зацикливание алгоритма разбора.

Для проверки новой версии библиотеки была использована вторая реализация, при этом парсер остался работоспособным и время его работы не изменилось.

\subsection{Повышение производительности}

Для сравнения производительности старой и новой версии библиотеки была использована та же реализация эталонного компилятора, что и в предыдущих разделах. В качестве тестового
набора использовались сгенерированные программы вида ``\lstinline|x1 := {expr}|'' для разной длины выражения.  Были проведены также замеры и для строк с несколькими
выражениями, то есть вида ``\lstinline|x1 := {expr}; ... xn := {expr}|'', однако оказалось, что время работы на таких входах пропорционально времени работы для одного присваивания,
поэтому для оценки производительности такие тесты далее не использовались. Тем не менее тестирование на нескольких присваиваниях выявило интересное свойство новой реализации:
увеличение числа присваиваний пропорционально увеличивает глубину рекурсивных вызовов для новой версии (при использовании старой версии такого не наблюдается). Это связано с тем,
что новая версия использует гораздо более глубокие рекурсивные вызовы, так как парсер-комбинатор \lstinline|seq| реализован таким образом, что второй парсер запускается в продолжении,
а значит требует дополнительное место на стеке. Поэтому при использовании новой версии необходимо правильно конфигурировать среду времени исполнения для выделения достаточного
количества памяти под стек.

Результаты апробации показаны в таблице~\ref{tab1}. Видно, что парсеры, написанные с помощью новой версии библиотеки, работают в несколько раз быстрее по сравнению со старой версией.
В первом столбце показан размер выражения (число знаков бинарных операций), а в двух других представлено время работы в секундах парсера эталонного компилятора, собранного с помощью старой версии библиотеки, и того же парсера, собранного с помощью новой версии.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Размер} & \multicolumn{2}{|c|}{\textbf{Время разбора, cек.}} \\
\cline{2-3}
\textbf{примера} & \textbf{Старая версия} & \textbf{Новая версия} \\
\hline
25& 0,25& 0,13 \\
\hline
50& 0,52& 0,24 \\
\hline
100& 2,13& 0,56 \\
\hline
200& 9,19& 1,97 \\
\hline
300& 21,93& 4,61 \\
\hline
400& 42,65& 9,50 \\
\hline
\end{tabular}
\vskip3mm
\caption{Результаты сравнения производительности старой и новой реализаций библиотеки}
\label{tab1}
\end{center}
\end{table}


\section{Заключение}

В рамках данной работы была выполнена реализация монадических парсер-комбинаторов использующих пользовательскую семантику. На основе алгоритма авторов библиотеки Meerkat был
разработан адаптированный алгоритм, который далее был интегрирован в библиотеку Ostap.

\begin{thebibliography}{00}
\bibitem{meerkat} A. Izmaylova, A. Afroozeh, and T. van der Storm T. Practical, General Parser Combinators // PEPM '16 Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation, pp. 1--12, 2016.
\bibitem{ostap} D. Boulytchev. Ostap: Parser Combinator Library and Syntax Extension for Objective Caml, 2009.
\bibitem{boulytchev2015combinators} D. Boulytchev. Combinators and Type-Driven Transformers in objective caml // Science of Computer Programming, Vol. 114, Elsevier, pp. 57--73, 2015.
\bibitem{meijer} G. Hutton and E. Meijer. Monadic Parser Combinators // Technical Report NOTTCS-TR-96-4, Department of Computer Science, University of Nottingham, 1996.
\bibitem{wadler} Ph. Wadler. Monads for functional programming // Proc. Marktoberdorf Summer school on program design calculi, 1992.
\bibitem{tratt} L. Tratt. Direct Left-Recursive Parsing Expression Grammars // Technical Report EIS-10-01, Middlesex University, 2010.
\bibitem{frost} R. A. Frost, R. Hafiz, and P. Callaghan. Parser Combinators for Ambiguous Left-Recursive Grammars // Practical Aspects of Declarative Languages, PADL’08, 2008.
\bibitem{warth} A. Warth, J. R. Douglass, and T. Millstein. Packrat Parsers Can Support Left Recursion // Partial Evaluation and Semantics-based Program Manipulation, PEPM ’08, pp. 103--110, 2016.
\bibitem{ford2002packrat} B. Ford. Packrat parsing:: simple, powerful, lazy, linear time, functional pearl // ACM SIGPLAN Notices, Vol. 37, No. 9, ACM, 2002.
\bibitem{ford2004parsing} B. Ford. Parsing expression grammars: a recognition-based syntactic foundation // ACM SIGPLAN Notices, Vol. 39, No. 1, ACM, 2004.
\bibitem{swierstra2001combinator} S. D. Swierstra. Combinator parsers: From toys to tools // Electronic Notes in Theoretical Computer Science, Vol. 41, No. 1, Elsevier, pp. 38--59, 2001.
\bibitem{knuth1968semantics} D. E. Knuth. Semantics of context-free languages // Mathematical systems theory, Vol. 2, No. 2, Springer, pp. 127--145, 1968.

\end{thebibliography}

\end{document}
